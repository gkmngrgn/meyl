use meyl;
use meyl::template::{generate_all_templates, ErrorKind};
use meyl::constants;
use std::fs;
use std::path::PathBuf;
use std::collections::HashMap;
use structopt::StructOpt;

#[derive(StructOpt)]
#[structopt(name = "meyl")]
struct Opt {
    #[structopt(subcommand)]
    cmd: Sub,
}

#[derive(StructOpt)]
#[structopt(about = "Static Email Generator")]
enum Sub {
    /// Create a new email template directory
    #[structopt(display_order = 1)]
    New {
        /// Email template directory
        #[structopt(short, long)]
        source: PathBuf,
    },

    /// Generates all available emails using [SOURCE] directory
    #[structopt(display_order = 2)]
    Generate {
        /// Source template directory
        #[structopt(short, long)]
        source: PathBuf,

        /// Output email directory
        #[structopt(short, long)]
        destination: PathBuf,
    },

    /// Sends a test mail to preview
    #[structopt(display_order = 3)]
    Send {
        /// Email template file
        #[structopt(short, long)]
        template: PathBuf,

        /// Email subject
        #[structopt(short, long)]
        subject: String,

        /// Receiver email
        #[structopt(short, long)]
        email: String,
    },
}

fn create_new_directory(path: &PathBuf) -> Result<(), ErrorKind> {
    if path.exists() {
        let msg = format!(
            "{:?} already exists. Try a different one or remove the directory.",
            path
        );
        return Err(ErrorKind::InvalidDirectory(msg));
    }
    let example_dir = path.join("src").join("example");
    let required_dirs = &[example_dir, path.join("dst")];
    for required_dir in required_dirs {
        if let Err(e) = fs::create_dir_all(&required_dir) {
            let msg = format!("{}", e);
            return Err(ErrorKind::InvalidDirectory(msg));
        }
    }
    let required_files = HashMap::new();
    required_files[&path.join("src").join(constants::FILE_STYLE)] = r#"
        html {
            background-color: #eee;
        }
    "#;
    required_files[&example_dir.join(constants::FILE_CONFIG)] = r#"
        [context_data]
        name = "Jane Smith"
    "#;
    required_files[&example_dir.join(constants::FILE_SUBJECT)] = r#"
        A simple template that generated by MEYL
    "#;
    required_files[&example_dir.join(constants::FILE_BODY_TEXT)] = r#"
        Dear {{ name }},

        This is a test email template to show you the directory structure.
    "#;
    required_files[&example_dir.join(constants::FILE_BODY)] = r#"
        {% extends "base.html" %}

        {% block content %}
            <h2>Dear {{ name }}<h2>

            <p>This is a test email template to show you the directory structure.</p>
        {% endblock %}
    "#;

    let mut file = fs::File::create(path.join("src").join(constants::FILE_STYLE)).unwrap();
    file.write_all(b"")


    // TODO 4: create <path>/src/style.css file
    // TODO 5: create <path>/src/base.html file
    Ok(())
}

fn main() {
    let opt = Opt::from_args();
    match opt.cmd {
        Sub::New { source } => match create_new_directory(&source) {
            Ok(_) => println!(
                "Your new email template directory is created in {:?}",
                source
            ),
            Err(e) => eprintln!("{}", e),
        },
        Sub::Generate {
            source,
            destination,
        } => match generate_all_templates(source, destination) {
            Ok(_) => println!("All templates are generated successfully."),
            Err(e) => eprintln!("{:?}", e),
        },
        Sub::Send {
            template,
            subject,
            email,
        } => {
            println!("command is send.");
            println!(
                "template: {:?}, subject: {}, email: {}",
                template, subject, email
            );
        }
    }
}
