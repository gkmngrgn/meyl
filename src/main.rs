use meyl;
use meyl::constants;
use meyl::template::{generate_all_templates, ErrorKind};
use std::collections::HashMap;
use std::fs;
use std::io::prelude::*;
use std::path::PathBuf;
use structopt::StructOpt;

#[derive(StructOpt)]
#[structopt(name = "meyl")]
struct Opt {
    #[structopt(subcommand)]
    cmd: Sub,
}

#[derive(StructOpt)]
#[structopt(about = "Static Email Generator")]
enum Sub {
    /// Create a new email template directory
    #[structopt(display_order = 1)]
    New {
        /// Email template directory
        #[structopt(short, long)]
        source: PathBuf,
    },

    /// Generates all available emails using [SOURCE] directory
    #[structopt(display_order = 2)]
    Generate {
        /// Source template directory
        #[structopt(short, long)]
        source: PathBuf,

        /// Output email directory
        #[structopt(short, long)]
        destination: PathBuf,
    },

    /// Sends a test mail to preview
    #[structopt(display_order = 3)]
    Send {
        /// Email template file
        #[structopt(short, long)]
        template: PathBuf,

        /// Email subject
        #[structopt(short, long)]
        subject: String,

        /// Receiver email
        #[structopt(short, long)]
        email: String,
    },
}

fn create_new_directory(path: &PathBuf) -> Result<(), ErrorKind> {
    if path.exists() {
        let msg = format!(
            "{:?} already exists. Try a different one or remove the directory.",
            path
        );
        return Err(ErrorKind::InvalidDirectory(msg));
    }

    // required directories
    let src_dir = &path.join("src");
    let dst_dir = &path.join("dst");
    let example_dir = &src_dir.join("example");
    let required_dirs = &[&example_dir, &dst_dir];
    for required_dir in required_dirs {
        if let Err(e) = fs::create_dir_all(&required_dir) {
            let msg = format!("{}", e);
            return Err(ErrorKind::InvalidDirectory(msg));
        }
    }

    // required files
    let mut required_files: HashMap<&PathBuf, &str> = HashMap::new();
    let path_style = &src_dir.join(constants::FILE_STYLE);
    required_files.insert(
        &path_style,
        r#"
        html {
            background-color: #eee;
        }
        "#,
    );

    let path_base_html = &src_dir.join("base.html");
    required_files.insert(&path_base_html, "{% block content %}{% endblock %}");

    let path_config = &example_dir.join(constants::FILE_CONFIG);
    required_files.insert(
        &path_config,
        r#"
        [context_data]
        name = "Jane Smith"
        "#,
    );

    let path_subject = &example_dir.join(constants::FILE_SUBJECT);
    required_files.insert(&path_subject, "A simple template that generated by MEYL");

    let path_body_text = &example_dir.join(constants::FILE_BODY_TEXT);
    required_files.insert(
        &path_body_text,
        r#"
        Dear {{ name }},

        This is a test email template to show you the directory structure.
        "#,
    );

    let path_body = &example_dir.join(constants::FILE_BODY);
    required_files.insert(
        &path_body,
        r#"
        {% extends "base.html" %}

        {% block content %}
            <h2>Dear {{ name }}<h2>

            <p>This is a test email template to show you the directory structure.</p>
        {% endblock %}
        "#,
    );

    for (file_path, content) in required_files {
        let mut file = fs::File::create(file_path).unwrap();
        file.write_all(content.as_bytes()).unwrap();
    }
    Ok(())
}

fn main() {
    let opt = Opt::from_args();
    match opt.cmd {
        Sub::New { source } => match create_new_directory(&source) {
            Ok(_) => println!(
                "Your new email template directory is created in {:?}",
                source
            ),
            Err(e) => eprintln!("{}", e),
        },
        Sub::Generate {
            source,
            destination,
        } => match generate_all_templates(source, destination) {
            Ok(_) => println!("All templates are generated successfully."),
            Err(e) => eprintln!("{:?}", e),
        },
        Sub::Send {
            template,
            subject,
            email,
        } => {
            println!("command is send.");
            println!(
                "template: {:?}, subject: {}, email: {}",
                template, subject, email
            );
        }
    }
}
